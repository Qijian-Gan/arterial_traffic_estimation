package networkInput;

/**
 * Created by Qijian-Gan on 10/13/2017.
 */
import java.util.ArrayList;
import java.util.Arrays;
import java.util.*;
import commonClass.forAimsunNetwork.*;
import commonClass.forAimsunNetwork.signalControl.*;
import commonClass.forAimsunNetwork.detector.*;
import commonClass.forAimsunNetwork.section.*;
import commonClass.forAimsunNetwork.junction.*;
import commonClass.forGeneralNetwork.*;
import commonClass.forGeneralNetwork.approach.*;
import commonClass.forGeneralNetwork.defaultSettings.*;
import commonClass.forGeneralNetwork.detector.*;
import commonClass.forGeneralNetwork.geometry.*;
import commonClass.forGeneralNetwork.lane.*;
import commonClass.forGeneralNetwork.section.*;
import commonClass.forGeneralNetwork.turning.*;
import main.MainFunction;

public class reconstructNetwork {

   //*************************************Major Functions********************************
    public static AimsunNetworkByApproach reconstructAimsunNetwork(){
        // This function is used to reconstruct Aimsun Network

        AimsunNetwork aimsunNetwork=readFromAimsun.readAimsunNetworkFiles();

        // Readjust junctions generated by centroids in aimsun
        aimsunNetwork.setAimsunJunctionList(ReAdjustJunctionGeneratedByCentroidsInAimsun(aimsunNetwork.getAimsunJunctionList()));

        // Get Linear and NonLinear Junctions
        // Linear: 1*1
        // Nonlinear: M*N (>1)
        List<AimsunJunction> linearJunction=getLinearOrNonLinearJunction(aimsunNetwork.getAimsunJunctionList(),"Linear");
        List<AimsunJunction> nonLinearJunction=getLinearOrNonLinearJunction(aimsunNetwork.getAimsunJunctionList(),"NonLinear");

        List<AimsunApproach> aimsunApproachList=new ArrayList<AimsunApproach>();

        // Loop for each nonlinear junction
        for (int i=0;i<nonLinearJunction.size();i++){
            int JunctionID=nonLinearJunction.get(i).getJunctionID();

            // Check the control plans for that junction
            List<AimsunControlPlanJunction> ControlPlanBelongToJunction=
                    getControlPlanBelongToJunction(JunctionID,aimsunNetwork.getAimsunControlPlanJunctionList(),
                            aimsunNetwork.getAimsunMasterControlPlanList());

            // Check each entrance sections
            for (int j=0;j<nonLinearJunction.get(i).getNumEntranceSections();j++){
                // Store the junction information
                AimsunJunction aimsunJunction=nonLinearJunction.get(i);

                // Get the junction ID and Name
                JunctionID=nonLinearJunction.get(i).getJunctionID();
                String JunctionName=nonLinearJunction.get(i).getJunctionName();

                // Get the junction External ID, City, County
                String JunctionExtID,City,County;
                if(nonLinearJunction.get(i).getJunctionExtID().equals("")){
                    JunctionExtID="N/A";
                    City="N/A";
                    County="N/A";
                }else{
                    List<String> stringList=findIDCityCounty(nonLinearJunction.get(i).getJunctionExtID());
                    JunctionExtID=stringList.get(0);
                    City=stringList.get(1);
                    County=stringList.get(2);
                }

                // Get whether it is signalized or not
                int Signalized=nonLinearJunction.get(i).getSignalized();
                // Get the section Information
                int FirstSectionID=nonLinearJunction.get(i).getEntranceSections()[j];
                System.out.println("Junction ID="+JunctionID+", Junction Name="+JunctionName+", First Section ID="+FirstSectionID);

                AimsunSection aimsunSection=findSectionInformation(FirstSectionID,aimsunNetwork.getAimsunSectionList());
                if(aimsunSection.equals(null)){
                    System.out.println("Can not find the section information!");
                    System.exit(-1);
                }
                String FirstSectionName=aimsunSection.getSectionName();
                String FirstSectionExtID=aimsunSection.getSectionExtID();

                // Find the links belonging to the same approach
                List<Integer> ListOfSections=findUpstreamSections(linearJunction, FirstSectionID);
                List<AimsunSection> aimsunSectionByApproachList=getSectionProperties(aimsunNetwork.getAimsunJunctionList(),
                        aimsunNetwork.getAimsunSectionList(), ListOfSections);
                SectionBelongToApproach sectionBelongToApproach=new SectionBelongToApproach(ListOfSections,aimsunSectionByApproachList);

                // Get turning properties at the downstream section
                TurningBelongToApproach turningBelongToApproach=findTurningsAtFirstSection(nonLinearJunction.get(i), FirstSectionID);

                // Lane-Turning Properties
                List<LaneTurningProperty> laneTurningProperty=findLaneTurningProperty(sectionBelongToApproach, turningBelongToApproach);

                // Get the aggregated road geometry: lanes, length, and turning pockets
                GeoDesign geoDesign=getGeometryDesign(sectionBelongToApproach, turningBelongToApproach, laneTurningProperty);

                // Get the detector information
                DetectorProperty detectorProperty=getDetectorProperty(sectionBelongToApproach,aimsunNetwork.getAimsunDetectorList());

                // Get default signal settings
                DefaultSignalSetting defaultSignalSetting=new DefaultSignalSetting(MainFunction.cBlock.CycleLength,
                        MainFunction.cBlock.LeftTurnGreen,MainFunction.cBlock.ThroughGreen,MainFunction.cBlock.RightTurnGreen,
                        MainFunction.cBlock.LeftTurnSetting);

                // Get midlink configuration files: This is used to get midlink counts
                // Currently not doing this.

                // Get control plans for each approach
                //ControlPlanBelongToJunction;

                // Add the tmpAimsunApproach to the end
                AimsunApproach tmpAimsunApproach=new AimsunApproach(JunctionID,JunctionName, JunctionExtID, City,
                        County, Signalized, FirstSectionID, FirstSectionName, FirstSectionExtID,
                        sectionBelongToApproach, turningBelongToApproach,laneTurningProperty, geoDesign,
                        detectorProperty,defaultSignalSetting, null,ControlPlanBelongToJunction,aimsunJunction);
                aimsunApproachList.add(tmpAimsunApproach);
            }
        }

        AimsunNetworkByApproach aimsunNetworkByApproach=new AimsunNetworkByApproach(aimsunNetwork,aimsunApproachList);
        System.out.println("Finish reconstructing the network!");
        return aimsunNetworkByApproach;
    }

    /**
     *
     * @param aimsunJunctionList List<AimsunJunction>
     * @return List<AimsunJunction>
     */
    public static List<AimsunJunction> ReAdjustJunctionGeneratedByCentroidsInAimsun(List<AimsunJunction> aimsunJunctionList){
        // This function is used to re-adjust junctions generated by centroids in Aimsun
        // E.g., 2 upstream links, 2 downstream links, but with 2 turns
        // Will add a new junction in order to separate this junction

        // First find the maximum ID
        int maxID=0;
        for(int i=0;i<aimsunJunctionList.size();i++){
            AimsunJunction aimsunJunction=aimsunJunctionList.get(i);
            // Check junction
            if(aimsunJunction.getJunctionID()>maxID){
                maxID=aimsunJunction.getJunctionID();
            }
            // Check upstream sections
            for(int j=0;j<aimsunJunction.getNumEntranceSections();j++){
                if(aimsunJunction.getEntranceSections()[j]>maxID){
                    maxID=aimsunJunction.getEntranceSections()[j];
                }
            }
            // Check downstream sections
            for(int j=0;j<aimsunJunction.getNumExitSections();j++){
                if(aimsunJunction.getExitSections()[j]>maxID){
                    maxID=aimsunJunction.getExitSections()[j];
                }
            }
            // Check turnings
            for(int j=0;j<aimsunJunction.getNumTurns();j++){
                if(aimsunJunction.getTurnings().get(j).getTurnID()>maxID){
                    maxID=aimsunJunction.getTurnings().get(j).getTurnID();
                }
            }
        }
        maxID=maxID+1; // Add one

        // Second, check those fake junctions generated by centroids
        List<AimsunJunction> aimsunJunctionListNew=new ArrayList<AimsunJunction>();
        for(int i=0;i<aimsunJunctionList.size();i++){
            AimsunJunction aimsunJunction=aimsunJunctionList.get(i);
            // Copy AimsunSectionTurning
            List<AimsunSectionTurning> aimsunSectionTurnings=new ArrayList<AimsunSectionTurning>();
            aimsunSectionTurnings.addAll(aimsunJunction.getSectionTurningList());
            // Copy AimsunTurning
            List<AimsunTurning> aimsunTurningList=new ArrayList<AimsunTurning>();
            aimsunTurningList.addAll(aimsunJunction.getTurnings());
            if(aimsunJunction.getNumTurns()==2 && aimsunJunction.getNumExitSections()==2 && aimsunJunction.getNumEntranceSections()==2){
                AimsunJunction aimsunJunctionNew=new AimsunJunction(aimsunJunction.getJunctionID(), aimsunJunction.getJunctionName(),
                        aimsunJunction.getJunctionExtID(), aimsunJunction.getSignalized(), aimsunJunction.getNumEntranceSections(),
                        aimsunJunction.getNumExitSections(), aimsunJunction.getNumTurns(), aimsunJunction.getEntranceSections(),
                        aimsunJunction.getExitSections(), aimsunTurningList, aimsunSectionTurnings);
                int UpstreamSection1=aimsunJunction.getEntranceSections()[0];
                int SectionIdx1=0;
                int UpstreamSection2=aimsunJunction.getEntranceSections()[1];
                int SectionIdx2=0;
                int TurnIdx1=0;
                int TurnIdx2=0;
                for(int j=0;j<aimsunJunction.getSectionTurningList().size();j++){
                    if(aimsunJunction.getSectionTurningList().get(j).getSectionID()==UpstreamSection1){
                        if(aimsunJunction.getSectionTurningList().get(j).getNumTurns()==1){
                            SectionIdx1=j;
                        }else{
                            System.out.println("Wrong setting of turnings; Wrong network connectivity!");
                            System.exit(-1);
                        }
                    }
                    if(aimsunJunction.getSectionTurningList().get(j).getSectionID()==UpstreamSection2){
                        if(aimsunJunction.getSectionTurningList().get(j).getNumTurns()==1){
                            SectionIdx2=j;
                        }else{
                            System.out.println("Wrong setting of turnings; Wrong network connectivity!");
                            System.exit(-1);
                        }
                    }
                }
                int DownstreamSection1=0;
                int DownstreamSection2=0;
                for(int j=0;j<aimsunJunction.getTurnings().size();j++){
                    if(aimsunJunction.getTurnings().get(j).getOrigSectionID()==UpstreamSection1){
                        DownstreamSection1=aimsunJunction.getTurnings().get(j).getDestSectionID();
                        TurnIdx1=j;
                    }
                    if(aimsunJunction.getTurnings().get(j).getOrigSectionID()==UpstreamSection2){
                        DownstreamSection2=aimsunJunction.getTurnings().get(j).getDestSectionID();
                        TurnIdx2=j;
                    }
                }

                //Remove upstream section2 and turn2 from aimsunJunctionList.get(i)
                aimsunJunctionList.get(i).setNumEntranceSections(1);
                aimsunJunctionList.get(i).setEntranceSections(new int[]{UpstreamSection1});
                aimsunJunctionList.get(i).setNumExitSections(1);
                aimsunJunctionList.get(i).setExitSections(new int[]{DownstreamSection1});
                aimsunJunctionList.get(i).setNumTurns(1);
                aimsunJunctionList.get(i).getTurnings().remove(TurnIdx2);
                aimsunJunctionList.get(i).getSectionTurningList().remove(SectionIdx2);

                //Remove upstream section1 and turn1 from aimsunApproachNew
                maxID=maxID+1;
                aimsunJunctionNew.setJunctionID(maxID);
                aimsunJunctionNew.setNumEntranceSections(1);
                aimsunJunctionNew.setEntranceSections(new int[]{UpstreamSection2});
                aimsunJunctionNew.setNumExitSections(1);
                aimsunJunctionNew.setExitSections(new int[]{DownstreamSection2});
                aimsunJunctionNew.setNumTurns(1);
                aimsunJunctionNew.getTurnings().remove(TurnIdx1);
                aimsunJunctionNew.getSectionTurningList().remove(SectionIdx1);
                // Add it to the temporary list
                aimsunJunctionListNew.add(aimsunJunctionNew);
            }
        }
        aimsunJunctionList.addAll(aimsunJunctionListNew);
        return aimsunJunctionList;
    }

    /**
     *
     * @param sectionBelongToApproach SectionBelongToApproach class
     * @param aimsunDetectorList List<AimsunDetector> class
     * @return DetectorProperty class
     */
    public static DetectorProperty getDetectorProperty(SectionBelongToApproach sectionBelongToApproach,
                                                       List<AimsunDetector> aimsunDetectorList){
        // This is the function to get the detector properties

        List<Integer> ListOfSections=sectionBelongToApproach.getListOfSections();
        List<AimsunSection> Property=sectionBelongToApproach.getProperty();

        // Get the detectors belonging to the sections
        List<AimsunDetector> selectedDetectorList=new ArrayList<AimsunDetector>();
        for(int j=0;j<aimsunDetectorList.size();j++){
            for(int i=0;i<ListOfSections.size();i++){
                if(ListOfSections.get(i)==aimsunDetectorList.get(j).getSectionID()){
                    selectedDetectorList.add(aimsunDetectorList.get(j));
                    break;
                }
            }
        }

        // Get the possible movements
        List<String> movementLeft=trafficMovementLibrary("Left");
        List<String> movementRight=trafficMovementLibrary("Right");
        List<String> movementAdvance=trafficMovementLibrary("Advance");
        List<String> movementGeneral=trafficMovementLibrary("General");

        // Initialize the movements belonging to different types
        List<DetectorMovementProperty> ExclusiveLeftTurn=new ArrayList<DetectorMovementProperty>();
        List<DetectorMovementProperty> ExclusiveRightTurn=new ArrayList<DetectorMovementProperty>();
        List<DetectorMovementProperty> AdvanceDetectors=new ArrayList<DetectorMovementProperty>();
        List<DetectorMovementProperty> GeneralStopbarDetectors=new ArrayList<DetectorMovementProperty>();

        // Check for exclusive left-turns
        for(int i=0;i<movementLeft.size();i++) {
            DetectorMovementProperty detectorMovementProperty = getDetectorMovementProperty
                    ("Stopbar",movementLeft.get(i), selectedDetectorList, Property);
            if(detectorMovementProperty!=null){
                ExclusiveLeftTurn.add(detectorMovementProperty);
            }
        }

        // Check for exclusive right-turns
        for(int i=0;i<movementRight.size();i++) {
            DetectorMovementProperty detectorMovementProperty = getDetectorMovementProperty
                    ("Stopbar",movementRight.get(i), selectedDetectorList, Property);
            if(detectorMovementProperty!=null){
                ExclusiveRightTurn.add(detectorMovementProperty);
            }
        }

        // Check for general detectors
        for(int i=0;i<movementGeneral.size();i++) {
            DetectorMovementProperty detectorMovementProperty = getDetectorMovementProperty
                    ("Stopbar",movementGeneral.get(i), selectedDetectorList, Property);
            if(detectorMovementProperty!=null){
                GeneralStopbarDetectors.add(detectorMovementProperty);
            }
        }

        // Check for Advance detectors
        for(int i=0;i<movementAdvance.size();i++) {
            DetectorMovementProperty detectorMovementProperty = getDetectorMovementProperty
                    ("Advance",movementAdvance.get(i), selectedDetectorList, Property);
            if(detectorMovementProperty!=null){
                AdvanceDetectors.add(detectorMovementProperty);
            }
        }

        DetectorProperty detectorProperty=new DetectorProperty(ExclusiveLeftTurn,ExclusiveRightTurn,
                AdvanceDetectors,GeneralStopbarDetectors);
        return detectorProperty;
    }

    /**
     *
     * @param Type String: Stopbar / Advance
     * @param MovementInput String: traffic movements in the function: trafficMovementLibrary(Type)
     * @param aimsunDetector List<AimsunDetector>  class
     * @param aimsunSection List<AimsunSection> class
     * @return DetectorMovementProperty class
     */
    public static DetectorMovementProperty getDetectorMovementProperty(String Type, String MovementInput,List<AimsunDetector> aimsunDetector,
                                                                       List<AimsunSection> aimsunSection){
        // This function is used to get the detector movement property
        DetectorMovementProperty detectorMovementProperty=null;

        List<Integer> DetectorIDs =new ArrayList<Integer>();
        List<Double> DetectorLengths =new ArrayList<Double>();
        List<Double> DistancesToStopbar =new ArrayList<Double>();
        List<Integer> NumberOfLanes =new ArrayList<Integer>();

        for(int i=0;i<aimsunDetector.size();i++){ // Loop for the selected detectors
            if(aimsunDetector.get(i).getMovement().equals(MovementInput)){ // If it matches the movement input
                // Add the detector ID,length, and number of lanes
                DetectorIDs.add(Integer.parseInt(aimsunDetector.get(i).getExternalID().trim()));
                DetectorLengths.add(aimsunDetector.get(i).getLength());
                NumberOfLanes.add(aimsunDetector.get(i).getNumOfLanes());

                if(Type.equals("Stopbar")){ // For stopbar detectors, distanceToStopbar=0
                    DistancesToStopbar.add(0.0);
                }else if(Type.equals("Advance")){ // For Advance detectors, search
                    double distance=0;
                    for(int j=0;j<aimsunSection.size();j++){
                        // Search the links from downstream to upstream
                        // Note the sections are organized from downstream to upstream

                        // Get the link/section lane length
                        double maxLaneLength=0;
                        for(int k=0;k<aimsunSection.get(j).getLaneLengths().length;k++){
                            if(aimsunSection.get(j).getLaneLengths()[k]>maxLaneLength){
                                maxLaneLength=aimsunSection.get(j).getLaneLengths()[k];
                            }
                        }
                        // If find the corresponding section
                        if(aimsunDetector.get(i).getSectionID()==aimsunSection.get(j).getSectionID()){
                            distance=distance+Math.max(0.0,maxLaneLength-
                                    (aimsunDetector.get(i).getInitialPosition()+aimsunDetector.get(i).getFinalPosition())/2);
                            break;
                        }
                        else{// If not found
                            distance=distance+maxLaneLength;
                        }
                    }
                    DistancesToStopbar.add(distance);
                }
            }
        }
        // If it is not empty
        if(!DetectorIDs.isEmpty()){
            detectorMovementProperty=new DetectorMovementProperty(MovementInput, DetectorIDs, DetectorLengths,
                    DistancesToStopbar,NumberOfLanes);
        }
        return detectorMovementProperty;
    }

    /**
     *
     * @param Type Left, Right, Advance, General
     * @return List<String> possibleMovements
     */
    public static List<String> trafficMovementLibrary(String Type){
        // This function returns the traffic movements belonging to a certain type/category
        List<String> possibleMovements=null;
        if(Type.equals("Left")){
            possibleMovements=new ArrayList(Arrays.asList("Left Turn","Left Turn Queue"));
        }else if(Type.equals("Right")){
            possibleMovements=new ArrayList(Arrays.asList("Right Turn","Right Turn Queue"));
        }else if(Type.equals("Advance")){
            possibleMovements=new ArrayList(Arrays.asList("Advance","Advance Left Turn",
                    "Advance Right Turn","Advance Through","Advance Through and Right","Advance Left and Through",
                    "Advance Left and Right"));
        }else if(Type.equals("General")){
            possibleMovements=new ArrayList(Arrays.asList("All Movements","Through","Left and Right",
                    "Left and Through","Through and Right"));
        }else{
            System.out.println("Unknown movement type!");
            System.exit(-1);
        }
        return possibleMovements;
    }


    /**
     *
     * @param sectionBelongToApproach SectionBelongToApproach class
     * @param turningBelongToApproach TurningBelongToApproach class
     * @param laneTurningProperty List<LaneTurningProperty> class
     * @return GeoDesign class
     */
    public static GeoDesign getGeometryDesign(SectionBelongToApproach sectionBelongToApproach,TurningBelongToApproach turningBelongToApproach,
                                              List<LaneTurningProperty> laneTurningProperty) {
        // This function is used to get the geometry design

        GeoDesign geoDesign = new GeoDesign(0, 0, 0,
                null, null,null);

        // Get the total link length
        double LinkLength = 0;
        for (int i = 0; i < sectionBelongToApproach.getListOfSections().size(); i++) {
            double maxLength = 0;
            //Get the max length of a given link
            for (int j = 0; j < sectionBelongToApproach.getProperty().get(i).getLaneLengths().length; j++) {
                if (sectionBelongToApproach.getProperty().get(i).getLaneLengths()[j] > maxLength) {
                    maxLength = sectionBelongToApproach.getProperty().get(i).getLaneLengths()[j];
                }
            }
            LinkLength = LinkLength + maxLength;
        }
        geoDesign.setLinkLength(LinkLength);

        // Get the number of upstream lanes (at the last section)
        // Only Check full lanes (it is possible upstream lane is not full lane)
        int NumOfUpstreamLanes = 0;
        for (int i = 0; i < sectionBelongToApproach.getProperty().get(sectionBelongToApproach.getProperty().size() - 1).getIsFullLane().length; i++) {
            if (sectionBelongToApproach.getProperty().get(sectionBelongToApproach.getProperty().size() - 1).getIsFullLane()[i] == 1) {
                NumOfUpstreamLanes = NumOfUpstreamLanes + 1;
            }
        }
        geoDesign.setNumOfUpstreamLanes(NumOfUpstreamLanes);

        // Get the turning pockets
        ExclusiveTurningProperty exclusiveTurningPropertyLeft=new ExclusiveTurningProperty(0,0 );
        ExclusiveTurningProperty exclusiveTurningPropertyRight=new ExclusiveTurningProperty(0,0 );
        int NumOfDownstreamLanes=0;
        for(int i=0;i<laneTurningProperty.get(0).getNumLanes();i++){// Loop for each lane
            if(laneTurningProperty.get(0).getLanes().get(i).getIsExclusive()==1 &&
                    laneTurningProperty.get(0).getLanes().get(i).getTurningMovements().size()>0){ // If it is exclusive and has associated turns
                for(int j=0;j<turningBelongToApproach.getTurningProperty().size();j++){
                    // Search the corresponding turning movement
                    if(laneTurningProperty.get(0).getLanes().get(i).getTurningMovements().get(0)==
                            turningBelongToApproach.getTurningProperty().get(j).getTurnID()){
                        // If it is an exclusive left-turn lane
                        if(turningBelongToApproach.getTurningProperty().get(j).getMovement().equals("Left Turn")){
                            if(exclusiveTurningPropertyLeft.getNumLanes()==0){
                                exclusiveTurningPropertyLeft.setNumLanes(1);
                                exclusiveTurningPropertyLeft.setPocket(laneTurningProperty.get(0).getLanes().get(i).getLength());
                            }else{
                                exclusiveTurningPropertyLeft.setNumLanes(exclusiveTurningPropertyLeft.getNumLanes()+1);
                                exclusiveTurningPropertyLeft.setPocket(Math.min(exclusiveTurningPropertyLeft.getPocket(),
                                        laneTurningProperty.get(0).getLanes().get(i).getLength()));
                            }
                        }
                        //If it is an exclusive right-turn lane
                        else if(turningBelongToApproach.getTurningProperty().get(j).getMovement().equals("Right Turn")) {
                            if(exclusiveTurningPropertyRight.getNumLanes()==0){
                                exclusiveTurningPropertyRight.setNumLanes(1);
                                exclusiveTurningPropertyRight.setPocket(laneTurningProperty.get(0).getLanes().get(i).getLength());
                            }else{
                                exclusiveTurningPropertyRight.setNumLanes(exclusiveTurningPropertyRight.getNumLanes()+1);
                                exclusiveTurningPropertyRight.setPocket(Math.min(exclusiveTurningPropertyRight.getPocket(),
                                        laneTurningProperty.get(0).getLanes().get(i).getLength()));
                            }
                        }
                        // For all other cases: through lane or no descriptions
                        else{
                            NumOfDownstreamLanes=NumOfDownstreamLanes+1;
                        }
                        break; // If found the corresponding turning movement, break.
                    }
                }
            }
            // If it is not an exclusive lane
            else
            {
                NumOfDownstreamLanes=NumOfDownstreamLanes+1;
            }
        }
        geoDesign.setExclusiveLeftTurn(exclusiveTurningPropertyLeft);
        geoDesign.setExclusiveRightTurn(exclusiveTurningPropertyRight);
        geoDesign.setNumOfDownstreamLanes(NumOfDownstreamLanes);

        // Update turn indicator
        int [] TurnIndicator=new int[]{0,0,0};
        for (int i=0;i<turningBelongToApproach.getTurningProperty().size();i++){
            if(turningBelongToApproach.getTurningProperty().get(i).getMovement().equals("Left Turn")){
                TurnIndicator[0]=1;
            }
            if(turningBelongToApproach.getTurningProperty().get(i).getMovement().equals("Through")){
                TurnIndicator[1]=1;
            }
            if(turningBelongToApproach.getTurningProperty().get(i).getMovement().equals("Right Turn")){
                TurnIndicator[2]=1;
            }
        }
        geoDesign.setTurnIndicator(TurnIndicator);

        return geoDesign;
    }

    /**
     *
     * @param sectionBelongToApproach SectionBelongToApproach class
     * @param turningBelongToApproach TurningBelongToApproach class
     * @return List<LaneTurningProperty> class
     */
    public static List<LaneTurningProperty> findLaneTurningProperty(SectionBelongToApproach sectionBelongToApproach,
                                                                    TurningBelongToApproach turningBelongToApproach){
        // This function is used to find the list of lane-turning properties

        List<LaneTurningProperty> laneTurningPropertyList=new ArrayList<LaneTurningProperty>();

        for(int i=0;i<sectionBelongToApproach.getListOfSections().size();i++){
            // Loop for the list of sections
            int SectionID=sectionBelongToApproach.getListOfSections().get(i);
            int NumLanes=sectionBelongToApproach.getProperty().get(i).getNumLanes();

            // Note: Lane ID=1:N from leftmost to rightmost
            //       Turn organized from leftmost to rightmost
            //       Each turn: fromLane (leftmost) to toLane (rightmost)
            //       Lane Length: from leftmost to rightmost
            List<LaneProperty> lanePropertyList=new ArrayList<LaneProperty>();
            for(int j=0;j<NumLanes;j++){
                int LaneID=j+1; // Get the lane ID; index starting from 0 in Java
                double Length=sectionBelongToApproach.getProperty().get(i).getLaneLengths()[j]; // Get the lane length

                // Get the turns using the current lane
                List<Integer> TurningMovements =new ArrayList<Integer>();
                for(int k=0;k<turningBelongToApproach.getTurningProperty().size();k++){
                    if(turningBelongToApproach.getTurningProperty().get(k).getOrigFromLane()<=LaneID &&
                            turningBelongToApproach.getTurningProperty().get(k).getOrigToLane()>=LaneID)
                        TurningMovements.add(turningBelongToApproach.getTurningProperty().get(k).getTurnID());
                }

                // Get whether it is exclusive or not
                int IsExclusive=1;
                if(TurningMovements.size()>1) {
                    IsExclusive = 0;
                }

                // Get the number of lanes by Turns
                int [] numLaneByTurn= new int[TurningMovements.size()];
                int totLane=0;
                for(int k=0;k<TurningMovements.size();k++){
                    // Get the number of lanes associated to a given turn
                    for(int p=0;p<turningBelongToApproach.getTurningProperty().size();p++){
                        if(turningBelongToApproach.getTurningProperty().get(p).getTurnID()==TurningMovements.get(k)){
                            numLaneByTurn[k]=turningBelongToApproach.getTurningProperty().get(p).getOrigToLane()-
                                    turningBelongToApproach.getTurningProperty().get(p).getOrigFromLane()+1;
                            totLane=totLane+numLaneByTurn[k];
                            break;
                        }
                    }
                }
                // Get the weighted proportions of turns in a given lane according to their number of lanes
                // within the section
                List<Double> Proportions=new ArrayList<Double>();
                for(int k=0;k<TurningMovements.size();k++){
                    Proportions.add(numLaneByTurn[k]*1.0/totLane);
                }

                // Append the lane property
                LaneProperty tmpLaneProperty=new LaneProperty(LaneID, IsExclusive, TurningMovements,Proportions, Length);
                lanePropertyList.add(tmpLaneProperty);
            }
            // Append the lane-turning property
            LaneTurningProperty tmpLaneTurningProperty=new LaneTurningProperty(SectionID, NumLanes, lanePropertyList);
            laneTurningPropertyList.add(tmpLaneTurningProperty);
        }
        return laneTurningPropertyList;
    }


    /**
     *
     * @param aimsunJunction AimsunJunction class
     * @param FirstSectionID First section ID (int)
     * @return TurningBelongToApproach class
     */
    public static TurningBelongToApproach findTurningsAtFirstSection(AimsunJunction aimsunJunction,int FirstSectionID){
        // This function is used to find turnings belonging to the first section

        int [] ListOfTurns=null;
        List<AimsunTurning> aimsunTurningList=new ArrayList<AimsunTurning>();
        for(int i=0;i<aimsunJunction.getSectionTurningList().size();i++){ // Loop for all section-turning components
            if(aimsunJunction.getSectionTurningList().get(i).getSectionID()==FirstSectionID){ // Check the section ID, if found
                ListOfTurns=aimsunJunction.getSectionTurningList().get(i).getTurnIDFromLeftToRight(); // Get the list of turns
                for(int j=0; j<ListOfTurns.length;j++){ // Loop for each turn
                    for(int k=0;k<aimsunJunction.getTurnings().size();k++){ // Loop for all turns belonging to the intersection
                        if(ListOfTurns[j]==aimsunJunction.getTurnings().get(k).getTurnID()){ // If the same turn ID found
                            aimsunTurningList.add(aimsunJunction.getTurnings().get(k)); // Append the turning property
                            break;
                        }
                    }
                }
            }
        }
        if(ListOfTurns.equals(null)){
            System.out.println("Can not find the turns!");
            System.exit(-1);
        }
        TurningBelongToApproach turningBelongToApproach=new TurningBelongToApproach(ListOfTurns,aimsunTurningList);
        return turningBelongToApproach;
    }


    /**
     *
     * @param aimsunJunctionList List<AimsunJunction> class
     * @param aimsunSectionList List<AimsunSection> class
     * @param ListOfSections List<Integer>
     * @return List<AimsunSection> class
     */
    public static List<AimsunSection> getSectionProperties(List<AimsunJunction> aimsunJunctionList, List<AimsunSection> aimsunSectionList,
                                                           List<Integer> ListOfSections){
        // This function is used to get/update the section information belonging to a given approach
        List<AimsunSection> aimsunSectionByApproachList=new ArrayList<AimsunSection>();

        for (int i=0;i<ListOfSections.size();i++){
            AimsunSection tmpAimsunSection=null;
            // Loop for the corresponding section
            for (int j=0;j<aimsunSectionList.size();j++){
                if(aimsunSectionList.get(j).getSectionID()==ListOfSections.get(i)){
                    tmpAimsunSection=aimsunSectionList.get(j);
                    break;
                }
            }
            if(tmpAimsunSection==null){
                System.out.println("Can not file the section information!");
                System.exit(-1);
            }
            // Loop for the downstream and upstream junctions
            boolean findUpstreamJunction=false;
            boolean findDownstreamJunction=false;
            for (int j=0;j<aimsunJunctionList.size();j++) {
                if (findDownstreamJunction == false){
                    for (int k = 0; k < aimsunJunctionList.get(j).getNumEntranceSections(); k++) {
                        if (aimsunJunctionList.get(j).getEntranceSections()[k] == ListOfSections.get(i)) {
                            tmpAimsunSection.setDownstreamJunction(aimsunJunctionList.get(j));
                            findDownstreamJunction=true;
                        }
                    }
                }
                if (findUpstreamJunction == false){
                    for (int k = 0; k < aimsunJunctionList.get(j).getNumExitSections(); k++) {
                        if (aimsunJunctionList.get(j).getExitSections()[k] == ListOfSections.get(i)) {
                            tmpAimsunSection.setUpstreamJunction(aimsunJunctionList.get(j));
                            findUpstreamJunction=true;
                        }
                    }
                }
            }
            aimsunSectionByApproachList.add(tmpAimsunSection);
        }
        return aimsunSectionByApproachList;
    }


    /**
     *
     * @param linearJunction List<AimsunJunction> class
     * @param SectionID Section ID (int)
     * @return List<Integer> ListOfSections
     */
    public static List<Integer>  findUpstreamSections(List<AimsunJunction> linearJunction, int SectionID){
        // This function is used to find upstream sections belonging to the same approach
        List<Integer> ListOfSections =new ArrayList<Integer>();

        // Find the upstream ones
        boolean findStatus=true;
        int ExitSection=SectionID;
        while(findStatus){
            int curAdd=0;
            for(int i=0;i<linearJunction.size();i++){ // Loop for all junctions
                curAdd=i;
                if(linearJunction.get(i).getExitSections()[0]==ExitSection){ //Find the right one?
                    ListOfSections.add(linearJunction.get(i).getExitSections()[0]);
                    ExitSection=linearJunction.get(i).getEntranceSections()[0];
                    break;
                }
            }
            if(curAdd>=linearJunction.size()-1){ // If can not find more, stop While()
                findStatus=false;
            }
        }

        ListOfSections.add(ExitSection); // Add the last section:ExitSection
        return ListOfSections;
    }

    /**
     *
     * @param SectionID Section ID (int)
     * @param aimsunSectionList List<AimsunSection> class
     * @return AimsunSection
     */
    public static AimsunSection findSectionInformation(int SectionID,List<AimsunSection> aimsunSectionList){
        // This function is used to find the information for a given section
        AimsunSection aimsunSection=null;
        for(int i=0;i<aimsunSectionList.size();i++){
            if(aimsunSectionList.get(i).getSectionID()==SectionID){
                aimsunSection=aimsunSectionList.get(i);
            }
        }
        return aimsunSection;
    }

    /**
     *
     * @param ExternalID External ID (String)
     * @return List<String>: ID, City, County
     */
    public static List<String> findIDCityCounty(String ExternalID){
        // This is the function to find Intersection ID, City, and County from the External ID
        List<String> stringList=new ArrayList<String>();
        String [] tmpLine=ExternalID.split(" ");

        if(tmpLine.length!=2){
            stringList.add("N/A"); //ID
            stringList.add("N/A"); //City
            stringList.add("N/A"); //County
        }else{
            stringList.add(tmpLine[1]);
            if(tmpLine[0].equals("AR")) {
                stringList.add("Arcadia");
                stringList.add("Los Angeles");
            }else if(tmpLine[0].equals("PA")){
                stringList.add("Pasadena");
                stringList.add("Los Angeles");
            }else{
                stringList.add(tmpLine[0]);
                stringList.add("N/A");
            }
        }
        return stringList;
    }

    /**
     *
     * @param JunctionID Junction ID
     * @param aimsunControlPlanJunction List<AimsunControlPlanJunction> class
     * @param aimsunMasterControlPlans List<AimsunMasterControlPlan> class
     * @return List<AimsunControlPlanJunction> class
     */
    public static List<AimsunControlPlanJunction> getControlPlanBelongToJunction(int JunctionID
            , List<AimsunControlPlanJunction> aimsunControlPlanJunction, List<AimsunMasterControlPlan> aimsunMasterControlPlans){
        // This function is to return the control plans belonging to the same junction ID

        List<AimsunControlPlanJunction> tmpAimsunControlPlanJunctionList=new ArrayList<AimsunControlPlanJunction>();
        List<Integer> PlanOffset=new ArrayList<Integer>();
        for (int i=0;i<aimsunControlPlanJunction.size();i++){ // Loop for each plan-junction
            if(aimsunControlPlanJunction.get(i).getJunctionID()==JunctionID){ // The same junction ID
                //Find the corresponding Master Control Plan
                AimsunControlPlanJunction tmpAimsunControlPlanJunction=getMasterControlPlanBelongToControlPlan
                        (aimsunControlPlanJunction.get(i),aimsunMasterControlPlans);

                tmpAimsunControlPlanJunctionList.add(tmpAimsunControlPlanJunction);
                PlanOffset.add(aimsunControlPlanJunction.get(i).getPlanOffset());
            }
        }
        // Organize the control plans according to the Plan Offsets
        Collections.sort(PlanOffset); //Sort the Plan Offset
        if(tmpAimsunControlPlanJunctionList.size()<=1){ // If less than or equal to one plan-junction
            return tmpAimsunControlPlanJunctionList;
        }else{ // If more than one, sort the plan-junction according to the plan offsets
            List<AimsunControlPlanJunction> AimsunControlPlanJunctionList= new ArrayList<AimsunControlPlanJunction>();
            for (int i=0;i<PlanOffset.size();i++) { // Loop for each plan Offset
                for (int j = 0; j < tmpAimsunControlPlanJunctionList.size(); j++) { // Loop for each plan-junction
                    if (tmpAimsunControlPlanJunctionList.get(j).getPlanOffset()==PlanOffset.get(i)){
                        AimsunControlPlanJunctionList.add(tmpAimsunControlPlanJunctionList.get(j));
                        break;
                    }
                }
            }
            return AimsunControlPlanJunctionList;
        }
    }

    /**
     *
     * @param aimsunControlPlanJunction AimsunControlPlanJunction class
     * @param aimsunMasterControlPlans List<AimsunMasterControlPlan> class
     * @return AimsunControlPlanJunction class
     */
    public static AimsunControlPlanJunction getMasterControlPlanBelongToControlPlan
            (AimsunControlPlanJunction aimsunControlPlanJunction,List<AimsunMasterControlPlan> aimsunMasterControlPlans){
        // This function is used to get the corresponding master control plans belonging to the same control plan

        AimsunControlPlanJunction tmpAimsunControlPlanJunction=aimsunControlPlanJunction;
        for (int i=0;i<aimsunMasterControlPlans.size();i++){
            if(aimsunMasterControlPlans.get(i).getControlPlanID()==tmpAimsunControlPlanJunction.getPlanID()){
                tmpAimsunControlPlanJunction.getMasterControlPlan().add(aimsunMasterControlPlans.get(i));
            }
        }
        return tmpAimsunControlPlanJunction;
    }

    /**
     *
     * @param aimsunJunctionList List<AimsunJunction> class
     * @param Type String: Linear /NonLinear
     * @return List<AimsunJunction> class
     */
    public static List<AimsunJunction> getLinearOrNonLinearJunction(List<AimsunJunction> aimsunJunctionList, String Type){
        // This function is used to get the linear (1-by-1) or non-linear(n-by-m) junction
        List<AimsunJunction> aimsunJunctionSelected=new ArrayList<AimsunJunction>();

        for (int i=0;i<aimsunJunctionList.size();i++){
            if(Type.equals("Linear")){
                if(aimsunJunctionList.get(i).getNumEntranceSections()==1 &&
                        aimsunJunctionList.get(i).getNumExitSections()==1){ // If not signalized & linear
                    aimsunJunctionSelected.add(aimsunJunctionList.get(i));
                }
            }else if(Type.equals("NonLinear")){
                if(aimsunJunctionList.get(i).getNumEntranceSections()>=1 &&
                        aimsunJunctionList.get(i).getNumExitSections()>=1 &&
                        aimsunJunctionList.get(i).getNumEntranceSections()+
                                aimsunJunctionList.get(i).getNumExitSections() >2){
                    // If nonlinear
                    aimsunJunctionSelected.add(aimsunJunctionList.get(i));
                }
            }
            else{
                System.out.println("Unknown junction type!");
                System.exit(-1);
            }
        }
        return aimsunJunctionSelected;
    }

}
